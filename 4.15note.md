## 小记
中缀表达式转后缀表达式
- 读输入
- 压入数据栈
- 符号准备入符号栈时，先判断与栈顶的符号比较优先级，如果栈顶的优先级高和相等，就把里面的符号全弹出去。
- 先右后左
- 数字叶子
后缀表达式：左右中
中缀表达式：左中右

## 作业
生成一个二叉搜索树

二叉树的创建是二叉树反复插入节点所构造出来的！

　　 　　若二叉树为空树，则插入元素作为树根节点。

　　 　　若根结点的键值等于key，则插入失败；

　　 　　若key小于根结点的键值，则插入到根的左子树上；否则，插入到根的右子树上

　　 　　新插入的节点一定是一个叶子节点！
```
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
    int data;
    struct node *lchild, *rchild;
} TreeNode;

typedef struct{
    TreeNode* fathernode;
} BinaryTree;

BinaryTree* Create_tree(void)
{
    BinaryTree* t=malloc(sizeof(BinaryTree));
    t->fathernode=NULL;
    return t;
}
int is_tree_empty(BinaryTree* t) {
    return t->fathernode == NULL;
}
BinaryTree*  insert_node(BinaryTree* t,int SIZE,int elem)
{
    
    for(int i=0;i<SIZE;i++)
  {
    TreeNode* node=(TreeNode*)malloc(sizeof(TreeNode));
    node->data=elem;
    node->lchild=NULL;
    node->rchild=NULL;
    if(is_tree_empty(t))
    {
    
       t->fathernode=node;
    
    }
    else
    {
        if(elem>t->fathernode->data)
        {
            t->fathernode->rchild=node;
            
        }
        else
        {
            t->fathernode->lchild=node;
        }
    }
  }
    return t;
}

void display_tree(TreeNode* fathernode) {
    if (fathernode== NULL) {
        printf("empty tree\n");
        return;
    }

    if (fathernode->lchild) {
        display_tree(fathernode->lchild);
    }

    printf("%d ", fathernode->data);

    if (fathernode->rchild) {
        display_tree(fathernode->rchild);
    }
}



int main(int argc, const char * argv[]) {
    int SIZE;
    BinaryTree* tree= Create_tree();
    int a[]={3,7,6,8,9,5,1,3,4,2};
    SIZE=sizeof(a)/sizeof(a[0]);
    
    for(int i=0;i<SIZE;i++){
        insert_node(tree,SIZE,a[i]);
    }
    display_tree(tree->fathernode);
    printf("\n");
    return 0;
}
```
写的代码运行有问题，还没找到。时间不够，先交，回去再看。
